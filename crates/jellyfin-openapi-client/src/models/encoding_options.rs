/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 10.8.3
 * 
 * Generated by: https://openapi-generator.tech
 */




#[derive(Clone, Debug, PartialEq, Default, Serialize, Deserialize)]
pub struct EncodingOptions {
    #[serde(rename = "EncodingThreadCount", skip_serializing_if = "Option::is_none")]
    pub encoding_thread_count: Option<i32>,
    #[serde(rename = "TranscodingTempPath", skip_serializing_if = "Option::is_none")]
    pub transcoding_temp_path: Option<String>,
    #[serde(rename = "FallbackFontPath", skip_serializing_if = "Option::is_none")]
    pub fallback_font_path: Option<String>,
    #[serde(rename = "EnableFallbackFont", skip_serializing_if = "Option::is_none")]
    pub enable_fallback_font: Option<bool>,
    #[serde(rename = "DownMixAudioBoost", skip_serializing_if = "Option::is_none")]
    pub down_mix_audio_boost: Option<f64>,
    #[serde(rename = "MaxMuxingQueueSize", skip_serializing_if = "Option::is_none")]
    pub max_muxing_queue_size: Option<i32>,
    #[serde(rename = "EnableThrottling", skip_serializing_if = "Option::is_none")]
    pub enable_throttling: Option<bool>,
    #[serde(rename = "ThrottleDelaySeconds", skip_serializing_if = "Option::is_none")]
    pub throttle_delay_seconds: Option<i32>,
    #[serde(rename = "HardwareAccelerationType", skip_serializing_if = "Option::is_none")]
    pub hardware_acceleration_type: Option<String>,
    /// Gets or sets the FFmpeg path as set by the user via the UI.
    #[serde(rename = "EncoderAppPath", skip_serializing_if = "Option::is_none")]
    pub encoder_app_path: Option<String>,
    /// Gets or sets the current FFmpeg path being used by the system and displayed on the transcode page.
    #[serde(rename = "EncoderAppPathDisplay", skip_serializing_if = "Option::is_none")]
    pub encoder_app_path_display: Option<String>,
    #[serde(rename = "VaapiDevice", skip_serializing_if = "Option::is_none")]
    pub vaapi_device: Option<String>,
    #[serde(rename = "EnableTonemapping", skip_serializing_if = "Option::is_none")]
    pub enable_tonemapping: Option<bool>,
    #[serde(rename = "EnableVppTonemapping", skip_serializing_if = "Option::is_none")]
    pub enable_vpp_tonemapping: Option<bool>,
    #[serde(rename = "TonemappingAlgorithm", skip_serializing_if = "Option::is_none")]
    pub tonemapping_algorithm: Option<String>,
    #[serde(rename = "TonemappingRange", skip_serializing_if = "Option::is_none")]
    pub tonemapping_range: Option<String>,
    #[serde(rename = "TonemappingDesat", skip_serializing_if = "Option::is_none")]
    pub tonemapping_desat: Option<f64>,
    #[serde(rename = "TonemappingThreshold", skip_serializing_if = "Option::is_none")]
    pub tonemapping_threshold: Option<f64>,
    #[serde(rename = "TonemappingPeak", skip_serializing_if = "Option::is_none")]
    pub tonemapping_peak: Option<f64>,
    #[serde(rename = "TonemappingParam", skip_serializing_if = "Option::is_none")]
    pub tonemapping_param: Option<f64>,
    #[serde(rename = "VppTonemappingBrightness", skip_serializing_if = "Option::is_none")]
    pub vpp_tonemapping_brightness: Option<f64>,
    #[serde(rename = "VppTonemappingContrast", skip_serializing_if = "Option::is_none")]
    pub vpp_tonemapping_contrast: Option<f64>,
    #[serde(rename = "H264Crf", skip_serializing_if = "Option::is_none")]
    pub h264_crf: Option<i32>,
    #[serde(rename = "H265Crf", skip_serializing_if = "Option::is_none")]
    pub h265_crf: Option<i32>,
    #[serde(rename = "EncoderPreset", skip_serializing_if = "Option::is_none")]
    pub encoder_preset: Option<String>,
    #[serde(rename = "DeinterlaceDoubleRate", skip_serializing_if = "Option::is_none")]
    pub deinterlace_double_rate: Option<bool>,
    #[serde(rename = "DeinterlaceMethod", skip_serializing_if = "Option::is_none")]
    pub deinterlace_method: Option<String>,
    #[serde(rename = "EnableDecodingColorDepth10Hevc", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth10_hevc: Option<bool>,
    #[serde(rename = "EnableDecodingColorDepth10Vp9", skip_serializing_if = "Option::is_none")]
    pub enable_decoding_color_depth10_vp9: Option<bool>,
    #[serde(rename = "EnableEnhancedNvdecDecoder", skip_serializing_if = "Option::is_none")]
    pub enable_enhanced_nvdec_decoder: Option<bool>,
    #[serde(rename = "PreferSystemNativeHwDecoder", skip_serializing_if = "Option::is_none")]
    pub prefer_system_native_hw_decoder: Option<bool>,
    #[serde(rename = "EnableIntelLowPowerH264HwEncoder", skip_serializing_if = "Option::is_none")]
    pub enable_intel_low_power_h264_hw_encoder: Option<bool>,
    #[serde(rename = "EnableIntelLowPowerHevcHwEncoder", skip_serializing_if = "Option::is_none")]
    pub enable_intel_low_power_hevc_hw_encoder: Option<bool>,
    #[serde(rename = "EnableHardwareEncoding", skip_serializing_if = "Option::is_none")]
    pub enable_hardware_encoding: Option<bool>,
    #[serde(rename = "AllowHevcEncoding", skip_serializing_if = "Option::is_none")]
    pub allow_hevc_encoding: Option<bool>,
    #[serde(rename = "EnableSubtitleExtraction", skip_serializing_if = "Option::is_none")]
    pub enable_subtitle_extraction: Option<bool>,
    #[serde(rename = "HardwareDecodingCodecs", skip_serializing_if = "Option::is_none")]
    pub hardware_decoding_codecs: Option<Vec<String>>,
    #[serde(rename = "AllowOnDemandMetadataBasedKeyframeExtractionForExtensions", skip_serializing_if = "Option::is_none")]
    pub allow_on_demand_metadata_based_keyframe_extraction_for_extensions: Option<Vec<String>>,
}

impl EncodingOptions {
    pub fn new() -> EncodingOptions {
        EncodingOptions {
            encoding_thread_count: None,
            transcoding_temp_path: None,
            fallback_font_path: None,
            enable_fallback_font: None,
            down_mix_audio_boost: None,
            max_muxing_queue_size: None,
            enable_throttling: None,
            throttle_delay_seconds: None,
            hardware_acceleration_type: None,
            encoder_app_path: None,
            encoder_app_path_display: None,
            vaapi_device: None,
            enable_tonemapping: None,
            enable_vpp_tonemapping: None,
            tonemapping_algorithm: None,
            tonemapping_range: None,
            tonemapping_desat: None,
            tonemapping_threshold: None,
            tonemapping_peak: None,
            tonemapping_param: None,
            vpp_tonemapping_brightness: None,
            vpp_tonemapping_contrast: None,
            h264_crf: None,
            h265_crf: None,
            encoder_preset: None,
            deinterlace_double_rate: None,
            deinterlace_method: None,
            enable_decoding_color_depth10_hevc: None,
            enable_decoding_color_depth10_vp9: None,
            enable_enhanced_nvdec_decoder: None,
            prefer_system_native_hw_decoder: None,
            enable_intel_low_power_h264_hw_encoder: None,
            enable_intel_low_power_hevc_hw_encoder: None,
            enable_hardware_encoding: None,
            allow_hevc_encoding: None,
            enable_subtitle_extraction: None,
            hardware_decoding_codecs: None,
            allow_on_demand_metadata_based_keyframe_extraction_for_extensions: None,
        }
    }
}


